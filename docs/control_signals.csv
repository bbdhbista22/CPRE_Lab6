Signal Name,Width (bits),Direction,Source,Destination,Type,Description,Active Level/Range
clk,1,Input,Zynq PS Clock,All PL modules,Clock,System clock (112 MHz target),Rising edge
resetn,1,Input,Zynq PS Reset,All PL modules,Reset,Active-low global reset,Low = Reset
,,,,,,,,
=== AXI-Lite Configuration Interface (CPU → Accelerator) ===,,,,,,,,
s_axi_aclk,1,Input,Zynq PS,Config Registers,Clock,AXI-Lite clock (same as system),Rising edge
s_axi_aresetn,1,Input,Zynq PS,Config Registers,Reset,AXI-Lite reset,Low = Reset
s_axi_awaddr,32,Input,Zynq PS,Config Registers,Address,Write address,0x4000_0000 base
s_axi_awvalid,1,Input,Zynq PS,Config Registers,Control,Write address valid,High = Valid
s_axi_awready,1,Output,Config Registers,Zynq PS,Control,Write address ready,High = Ready
s_axi_wdata,32,Input,Zynq PS,Config Registers,Data,Write data,32-bit config value
s_axi_wvalid,1,Input,Zynq PS,Config Registers,Control,Write data valid,High = Valid
s_axi_wready,1,Output,Config Registers,Zynq PS,Control,Write data ready,High = Ready
s_axi_bresp,2,Output,Config Registers,Zynq PS,Status,Write response,00 = OK
s_axi_bvalid,1,Output,Config Registers,Zynq PS,Control,Write response valid,High = Valid
s_axi_bready,1,Input,Zynq PS,Config Registers,Control,Write response ready,High = Ready
s_axi_araddr,32,Input,Zynq PS,Config Registers,Address,Read address,0x4000_0000 base
s_axi_arvalid,1,Input,Zynq PS,Config Registers,Control,Read address valid,High = Valid
s_axi_arready,1,Output,Config Registers,Zynq PS,Control,Read address ready,High = Ready
s_axi_rdata,32,Output,Config Registers,Zynq PS,Data,Read data,32-bit register value
s_axi_rresp,2,Output,Config Registers,Zynq PS,Status,Read response,00 = OK
s_axi_rvalid,1,Output,Config Registers,Zynq PS,Control,Read data valid,High = Valid
s_axi_rready,1,Input,Zynq PS,Config Registers,Control,Read data ready,High = Ready
,,,,,,,,
=== Configuration Register Values (Offset from base 0x4000_0000) ===,,,,,,,,
CONTROL [0x00],32,R/W,CPU,Accelerator,Config,"Bit 0: conv_start, Bit 1: reset, Bit 2: swap_in_buf, Bit 3: swap_out_buf, Bit 31: conv_done (RO)",Various
INPUT_HEIGHT [0x04],32,R/W,CPU,Index Generator,Config,Input feature map height (e.g. 64),1 to 256
INPUT_WIDTH [0x08],32,R/W,CPU,Index Generator,Config,Input feature map width (e.g. 64),1 to 256
INPUT_CHANNELS [0x0C],32,R/W,CPU,Index Generator,Config,Number of input channels (e.g. 3 for RGB),1 to 512
FILTER_HEIGHT [0x10],32,R/W,CPU,Index Generator,Config,Convolution filter height (e.g. 3),1 to 11
FILTER_WIDTH [0x14],32,R/W,CPU,Index Generator,Config,Convolution filter width (e.g. 3),1 to 11
NUM_FILTERS [0x18],32,R/W,CPU,Index Generator,Config,Number of output channels/filters (e.g. 64),Must be multiple of 4
STRIDE [0x1C],32,R/W,CPU,Index Generator,Config,Convolution stride (e.g. 1),1 or 2
PADDING [0x20],32,R/W,CPU,Index Generator,Config,Zero-padding pixels (e.g. 1),0 to 3
SCALE_FACTOR [0x24],32,R/W,CPU,Dequantization,Config,Fixed-point scale factor in Q8.24 format,Computed from quantization params
ZERO_POINT_IN [0x28],32,R/W,CPU,Dequantization,Config,Input zero-point (sign-extended to 32-bit),-128 to 127
ZERO_POINT_OUT [0x2C],32,R/W,CPU,Dequantization,Config,Output zero-point for next layer,-128 to 127
ENABLE_POOLING [0x30],32,R/W,CPU,Output Storage,Config,1 = Enable 2x2 max pooling; 0 = No pooling,0 or 1
ENABLE_RELU [0x34],32,R/W,CPU,Dequantization,Config,1 = Enable ReLU activation; 0 = No ReLU,0 or 1
BIAS_BASE_ADDR [0x38],32,R/W,CPU,MAC Stream Provider,Config,BRAM address of bias values for this layer,BRAM address
OUTPUT_HEIGHT [0x3C],32,R/W,CPU,Output Storage,Config,Output feature map height (computed or explicit),1 to 256
OUTPUT_WIDTH [0x40],32,R/W,CPU,Output Storage,Config,Output feature map width (computed or explicit),1 to 256
,,,,,,,,
=== Index Generator → MAC Stream Provider (AXI-Stream) ===,,,,,,,,
idx_axis_tdata,32,Output,Index Generator,MAC Stream Provider,Data,"{input_addr[15:0], weight_addr[15:0]}",Address pairs
idx_axis_tvalid,1,Output,Index Generator,MAC Stream Provider,Control,Address pair valid,High = Valid
idx_axis_tready,1,Input,MAC Stream Provider,Index Generator,Control,Ready for next address pair,High = Ready
idx_axis_tlast,1,Output,Index Generator,MAC Stream Provider,Control,Last address in MAC accumulation (every 27 for Conv1),High = Last
,,,,,,,,
=== MAC Stream Provider → 4× MAC Units (AXI-Stream) ===,,,,,,,,
mac_axis_tdata[0],16,Output,MAC Stream Provider,MAC Unit 0,Data,"{weight[7:0], activation[7:0]} for channel 0 mod 4",int8 pairs
mac_axis_tdata[1],16,Output,MAC Stream Provider,MAC Unit 1,Data,"{weight[7:0], activation[7:0]} for channel 1 mod 4",int8 pairs
mac_axis_tdata[2],16,Output,MAC Stream Provider,MAC Unit 2,Data,"{weight[7:0], activation[7:0]} for channel 2 mod 4",int8 pairs
mac_axis_tdata[3],16,Output,MAC Stream Provider,MAC Unit 3,Data,"{weight[7:0], activation[7:0]} for channel 3 mod 4",int8 pairs
mac_axis_tvalid,1,Output,MAC Stream Provider,All 4 MACs,Control,Data valid (broadcast to all MACs),High = Valid
mac_axis_tready,1,Input,All 4 MACs (AND),MAC Stream Provider,Control,All MACs ready (ANDed together),High = Ready
mac_axis_tlast,1,Output,MAC Stream Provider,All 4 MACs,Control,Last MAC in accumulation (reset accumulator after this),High = Last
mac_axis_tuser[0],32,Output,Config Registers,MAC Unit 0,Data,Bias value for channel 0 mod 4,int32 bias
mac_axis_tuser[1],32,Output,Config Registers,MAC Unit 1,Data,Bias value for channel 1 mod 4,int32 bias
mac_axis_tuser[2],32,Output,Config Registers,MAC Unit 2,Data,Bias value for channel 2 mod 4,int32 bias
mac_axis_tuser[3],32,Output,Config Registers,MAC Unit 3,Data,Bias value for channel 3 mod 4,int32 bias
,,,,,,,,
=== 4× MAC Units → Output Combiner (AXI-Stream) ===,,,,,,,,
mac_out_tdata[0],32,Output,MAC Unit 0,Output Combiner,Data,32-bit accumulator output from MAC 0,int32 sum
mac_out_tdata[1],32,Output,MAC Unit 1,Output Combiner,Data,32-bit accumulator output from MAC 1,int32 sum
mac_out_tdata[2],32,Output,MAC Unit 2,Output Combiner,Data,32-bit accumulator output from MAC 2,int32 sum
mac_out_tdata[3],32,Output,MAC Unit 3,Output Combiner,Data,32-bit accumulator output from MAC 3,int32 sum
mac_out_tvalid[0],1,Output,MAC Unit 0,Output Combiner,Control,MAC 0 output valid,High = Valid
mac_out_tvalid[1],1,Output,MAC Unit 1,Output Combiner,Control,MAC 1 output valid,High = Valid
mac_out_tvalid[2],1,Output,MAC Unit 2,Output Combiner,Control,MAC 2 output valid,High = Valid
mac_out_tvalid[3],1,Output,MAC Unit 3,Output Combiner,Control,MAC 3 output valid,High = Valid
mac_out_tready[0],1,Input,Output Combiner,MAC Unit 0,Control,Ready for MAC 0 output,High = Ready
mac_out_tready[1],1,Input,Output Combiner,MAC Unit 1,Control,Ready for MAC 1 output,High = Ready
mac_out_tready[2],1,Input,Output Combiner,MAC Unit 2,Control,Ready for MAC 2 output,High = Ready
mac_out_tready[3],1,Input,Output Combiner,MAC Unit 3,Control,Ready for MAC 3 output,High = Ready
mac_out_tlast[0],1,Output,MAC Unit 0,Output Combiner,Control,Last output from MAC 0 for this pixel,High = Last
mac_out_tlast[1],1,Output,MAC Unit 1,Output Combiner,Control,Last output from MAC 1 for this pixel,High = Last
mac_out_tlast[2],1,Output,MAC Unit 2,Output Combiner,Control,Last output from MAC 2 for this pixel,High = Last
mac_out_tlast[3],1,Output,MAC Unit 3,Output Combiner,Control,Last output from MAC 3 for this pixel,High = Last
,,,,,,,,
=== Output Combiner → Dequantization (AXI-Stream) ===,,,,,,,,
comb_axis_tdata,32,Output,Output Combiner,Dequantization,Data,32-bit accumulator (round-robin from 4 MACs),int32 sum
comb_axis_tid,2,Output,Output Combiner,Dequantization,Control,Source MAC ID (0-3),0 to 3
comb_axis_tvalid,1,Output,Output Combiner,Dequantization,Control,Data valid,High = Valid
comb_axis_tready,1,Input,Dequantization,Output Combiner,Control,Ready for data,High = Ready
comb_axis_tlast,1,Output,Output Combiner,Dequantization,Control,Last in packet,High = Last
,,,,,,,,
=== Dequantization → Output Storage (AXI-Stream) ===,,,,,,,,
dequant_axis_tdata,8,Output,Dequantization,Output Storage,Data,8-bit quantized output,int8 value [-128, 127]
dequant_axis_tid,2,Output,Dequantization,Output Storage,Control,Propagated MAC ID (for address calculation),0 to 3
dequant_axis_tvalid,1,Output,Dequantization,Output Storage,Control,Data valid,High = Valid
dequant_axis_tready,1,Input,Output Storage,Dequantization,Control,Ready for data (may stall during BRAM RMW),High = Ready
dequant_axis_tlast,1,Output,Dequantization,Output Storage,Control,Last output for pixel,High = Last
,,,,,,,,
=== BRAM Interface Signals (Multiple Ports) ===,,,,,,,,
,,,,,,,,
--- Input Activation BRAM (Port A: CDMA Write; Port B: Accelerator Read) ---,,,,,,,,
in_bram_addr_b,16,Output,MAC Stream Provider,Input BRAM,Address,Read address from accelerator,Word address
in_bram_dout_b,32,Input,Input BRAM,MAC Stream Provider,Data,Read data (4× int8 packed),32-bit word
in_bram_en_b,1,Output,MAC Stream Provider,Input BRAM,Control,Enable port B,High = Enable
in_bram_we_b,4,Output,MAC Stream Provider,Input BRAM,Control,Write enable (should be 0 for read-only),0000 = Read
in_swap_buffer,1,Input,CPU (Config Reg),BRAM Mux,Control,Select input buffer: 0=Buffer A; 1=Buffer B,0 or 1
,,,,,,,,
--- Output Activation BRAM (Port A: Accelerator Write; Port B: CDMA Read) ---,,,,,,,,
out_bram_addr_a,16,Output,Output Storage,Output BRAM,Address,Write address from accelerator,Word address
out_bram_din_a,32,Output,Output Storage,Output BRAM,Data,Write data (4× int8 packed),32-bit word
out_bram_dout_a,32,Input,Output BRAM,Output Storage,Data,Read data for RMW cycle,32-bit word
out_bram_en_a,1,Output,Output Storage,Output BRAM,Control,Enable port A,High = Enable
out_bram_we_a,4,Output,Output Storage,Output BRAM,Control,Write enable (byte-level),1111 = Write all bytes
out_swap_buffer,1,Input,CPU (Config Reg),BRAM Mux,Control,Select output buffer: 0=Buffer A; 1=Buffer B,0 or 1
,,,,,,,,
--- Weight BRAM Bank 0 (Port A: CDMA Write; Port B: Accelerator Read) ---,,,,,,,,
wt0_bram_addr_b,16,Output,MAC Stream Provider,Weight Bank 0,Address,Read address for weights (output channel 0 mod 4),Word address
wt0_bram_dout_b,32,Input,Weight Bank 0,MAC Stream Provider,Data,Read data (4× int8 weights packed),32-bit word
wt0_bram_en_b,1,Output,MAC Stream Provider,Weight Bank 0,Control,Enable port B,High = Enable
wt0_swap_buffer,1,Input,CPU (Config Reg),Weight Bank 0 Mux,Control,Select buffer: 0=Buffer A; 1=Buffer B,0 or 1
,,,,,,,,
--- Weight BRAM Bank 1 (Port A: CDMA Write; Port B: Accelerator Read) ---,,,,,,,,
wt1_bram_addr_b,16,Output,MAC Stream Provider,Weight Bank 1,Address,Read address for weights (output channel 1 mod 4),Word address
wt1_bram_dout_b,32,Input,Weight Bank 1,MAC Stream Provider,Data,Read data (4× int8 weights packed),32-bit word
wt1_bram_en_b,1,Output,MAC Stream Provider,Weight Bank 1,Control,Enable port B,High = Enable
wt1_swap_buffer,1,Input,CPU (Config Reg),Weight Bank 1 Mux,Control,Select buffer: 0=Buffer A; 1=Buffer B,0 or 1
,,,,,,,,
--- Weight BRAM Bank 2 (Port A: CDMA Write; Port B: Accelerator Read) ---,,,,,,,,
wt2_bram_addr_b,16,Output,MAC Stream Provider,Weight Bank 2,Address,Read address for weights (output channel 2 mod 4),Word address
wt2_bram_dout_b,32,Input,Weight Bank 2,MAC Stream Provider,Data,Read data (4× int8 weights packed),32-bit word
wt2_bram_en_b,1,Output,MAC Stream Provider,Weight Bank 2,Control,Enable port B,High = Enable
wt2_swap_buffer,1,Input,CPU (Config Reg),Weight Bank 2 Mux,Control,Select buffer: 0=Buffer A; 1=Buffer B,0 or 1
,,,,,,,,
--- Weight BRAM Bank 3 (Port A: CDMA Write; Port B: Accelerator Read) ---,,,,,,,,
wt3_bram_addr_b,16,Output,MAC Stream Provider,Weight Bank 3,Address,Read address for weights (output channel 3 mod 4),Word address
wt3_bram_dout_b,32,Input,Weight Bank 3,MAC Stream Provider,Data,Read data (4× int8 weights packed),32-bit word
wt3_bram_en_b,1,Output,MAC Stream Provider,Weight Bank 3,Control,Enable port B,High = Enable
wt3_swap_buffer,1,Input,CPU (Config Reg),Weight Bank 3 Mux,Control,Select buffer: 0=Buffer A; 1=Buffer B,0 or 1
,,,,,,,,
=== Top-Level Control Signals ===,,,,,,,,
conv_start,1,Input,CPU (Config Reg),Index Generator,Control,Start convolution computation,High = Start (self-clearing)
conv_idle,1,Output,Index Generator,CPU (Config Reg),Status,Accelerator idle and ready for new layer,High = Idle
conv_done,1,Output,Output Storage,CPU (Config Reg),Status,Layer computation complete,High = Done
interrupt_out,1,Output,Accelerator Core,Zynq PS GIC,Interrupt,Interrupt CPU when conv_done asserts,Rising edge triggers
,,,,,,,,
=== CDMA Control Signals (AXI Interface) ===,,,,,,,,
cdma_axi_awaddr,32,Output,CDMA,AXI Interconnect,Address,Write address to BRAM,0x8000_0000 base
cdma_axi_awvalid,1,Output,CDMA,AXI Interconnect,Control,Write address valid,High = Valid
cdma_axi_awready,1,Input,AXI Interconnect,CDMA,Control,Write address ready,High = Ready
cdma_axi_wdata,32,Output,CDMA,AXI Interconnect,Data,Write data to BRAM,32-bit data
cdma_axi_wvalid,1,Output,CDMA,AXI Interconnect,Control,Write data valid,High = Valid
cdma_axi_wready,1,Input,AXI Interconnect,CDMA,Control,Write data ready,High = Ready
cdma_axi_araddr,32,Output,CDMA,AXI Interconnect,Address,Read address from DDR,DDR address
cdma_axi_arvalid,1,Output,CDMA,AXI Interconnect,Control,Read address valid,High = Valid
cdma_axi_arready,1,Input,AXI Interconnect,CDMA,Control,Read address ready,High = Ready
cdma_axi_rdata,32,Input,AXI Interconnect,CDMA,Data,Read data from DDR,32-bit data
cdma_axi_rvalid,1,Input,AXI Interconnect,CDMA,Control,Read data valid,High = Valid
cdma_axi_rready,1,Output,CDMA,AXI Interconnect,Control,Read data ready,High = Ready
,,,,,,,,
=== Debug/Status Signals (Optional) ===,,,,,,,,
debug_state_idx,3,Output,Index Generator,ILA/Debug,Debug,Current state of index generator FSM,Encoding TBD
debug_state_out,3,Output,Output Storage,ILA/Debug,Debug,Current state of output storage FSM,Encoding TBD
debug_mac_count,32,Output,Index Generator,ILA/Debug,Debug,Number of MACs issued so far,Counter value
debug_pixel_count,32,Output,Output Storage,ILA/Debug,Debug,Number of output pixels written,Counter value
debug_backpressure,1,Output,MAC Stream Provider,ILA/Debug,Debug,Backpressure detected,High = Stalled
,,,,,,,,
=== Notes ===,,,,,,,,
"1. All AXI-Stream interfaces follow AXI4-Stream protocol with TVALID/TREADY handshaking",,,,,,,,
"2. BRAM interfaces have 1-cycle read latency (address valid at cycle N; data valid at cycle N+1)",,,,,,,,
"3. Config registers use memory-mapped I/O via AXI-Lite at base address 0x4000_0000",,,,,,,,
"4. Buffer swap signals allow ping-pong operation: output of layer N becomes input of layer N+1",,,,,,,,
"5. TID field (2 bits) indicates which of 4 MACs produced the data (for output address calculation)",,,,,,,,
"6. TLAST marks the end of MAC accumulation for a single output pixel (every 27 MACs for Conv1 3×3×3)",,,,,,,,
"7. Double-buffering on weights allows CDMA to load next layer while current layer computes",,,,,,,,
